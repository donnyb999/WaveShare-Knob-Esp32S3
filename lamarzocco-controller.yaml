substitutions:
  # La Marzocco entity IDs - update these to match your Home Assistant setup
  # These are typically auto-discovered by the La Marzocco integration
  lm_entity: "lamarzocco.micra"  # Update to your actual entity ID
  lm_power: "switch.micra"  # Update if different
  lm_coffee_temp: "number.micra_coffee_target_temperature"  # Update if different
  lm_steam_level: "select.micra_steam_level"  # Update if different
  lm_prebrew_mode: "select.micra_prebrew_infusion_mode"  # Update if different
  lm_preinfusion_time: "number.micra_preinfusion_time"  # Update if different
  lm_status: "binary_sensor.micra_brewing_active"  # Update if different
  lm_brewing_start: "sensor.micra_brewing_start_time"  # Update if different

esphome:
  name: lamarzocco-controller
  on_boot:
    priority: 200
    then:
      - delay: 5s  # Wait for Home Assistant connection
      - script.execute: initialize_ui_values

packages:
#remote package files are necessary - DO NOT REMOVE
  remote_package_files:
    url: https://github.com/donnyb999/WaveShare-Knob-Esp32S3
    files: [lamarzocco/waveshare.yaml,lamarzocco/esp-config.yaml,lamarzocco/ha-config.yaml] 
#  lvgl: !include lamarzocco/lvgl.yaml

# External component for ST77916 display
external_components:
  - source:
      type: git
      url: https://github.com/donnyb999/WaveShare-Knob-Esp32S3
      ref: main
    refresh: always
    
  - source: github://pr#10392
    components: [mipi_spi]
    refresh: 1d

# Font definition
font:
  - file: "gfonts://Roboto"
    id: roboto_small
    size: 16
  - file: "gfonts://Roboto"
    id: roboto
    size: 20
  - file: "gfonts://Roboto"
    id: roboto_28
    size: 28
  - file: "gfonts://Roboto"
    id: roboto_36
    size: 36
  - file: "gfonts://Roboto"
    id: roboto_48
    size: 48

image:
  - file: "https://github.com/donnyb999/WaveShare-Knob-Esp32S3/blob/main/lamarzocco/lm logo.png"
    id: lm_logo_background_image
    type: RGB565
    resize: 360x360
    transparency: alpha_channel

# Global variables for UI state
globals:
  - id: selected_element
    type: int
    restore_value: false
    initial_value: '-1'  # -1 = nothing selected, 0-5 = element indices
    
  - id: selection_timeout
    type: int
    restore_value: false
    initial_value: '0'  # Timestamp when selection expires
    
  - id: brewing_duration
    type: float
    restore_value: false
    initial_value: '0.0'  # Current brewing duration in seconds
    
  - id: temp_new_value
    type: float
    restore_value: false
    initial_value: '89.0'
    
  - id: steam_new_value
    type: std::string
    restore_value: false
    #initial_value: ""
    
  - id: prebrew_new_value
    type: std::string
    restore_value: false
    #initial_value: ""
    
  - id: preinfusion_new_value
    type: float
    restore_value: false
    initial_value: '7.3'
  
  # Working values for encoder adjustments (accumulate changes locally)
  - id: working_temp_value
    type: float
    restore_value: false
    initial_value: '89.0'
  - id: working_preinfusion_value
    type: float
    restore_value: false
    initial_value: '7.3'
    
  - id: handle_power_toggle
    type: bool
    restore_value: false
    initial_value: 'false'
  - id: handle_temp_change
    type: bool
    restore_value: false
    initial_value: 'false'
  - id: handle_steam_change
    type: bool
    restore_value: false
    initial_value: 'false'
  - id: handle_prebrew_change
    type: bool
    restore_value: false
    initial_value: 'false'
  - id: handle_preinfusion_change
    type: bool
    restore_value: false
    initial_value: 'false'
  - id: send_ha_command
    type: bool
    restore_value: false
    initial_value: 'false'
  
  # Verification tracking
  - id: verifying_element
    type: int
    restore_value: false
    initial_value: '-1'  # -1 = not verifying, 0-5 = element index
  - id: sent_temp_value
    type: float
    restore_value: false
    initial_value: '0.0'
  - id: sent_preinfusion_value
    type: float
    restore_value: false
    initial_value: '0.0'
  - id: sent_steam_value
    type: std::string
    restore_value: false
    #initial_value: ""
  - id: sent_prebrew_value
    type: std::string
    restore_value: false
    #initial_value: ""
  - id: power_pending
    type: bool
    restore_value: false
    initial_value: 'false'
  - id: power_timeout_ms
    type: uint32_t
    restore_value: false
    initial_value: '0'
  - id: temp_pending
    type: bool
    restore_value: false
    initial_value: 'false'
  - id: temp_timeout_ms
    type: uint32_t
    restore_value: false
    initial_value: '0'
  - id: steam_pending
    type: bool
    restore_value: false
    initial_value: 'false'
  - id: steam_timeout_ms
    type: uint32_t
    restore_value: false
    initial_value: '0'
  - id: prebrew_pending
    type: bool
    restore_value: false
    initial_value: 'false'
  - id: prebrew_timeout_ms
    type: uint32_t
    restore_value: false
    initial_value: '0'
  - id: preinfusion_pending
    type: bool
    restore_value: false
    initial_value: 'false'
  - id: preinfusion_timeout_ms
    type: uint32_t
    restore_value: false
    initial_value: '0'
  - id: verification_success
    type: bool
    restore_value: false
    initial_value: 'false'
    
  - id: power_label_text
    type: std::string
    restore_value: false
    initial_value: '"Power: OFF"'
    
  - id: temp_label_text
    type: std::string
    restore_value: false
    initial_value: '"Temp: --.-C"'
    
  - id: steam_label_text
    type: std::string
    restore_value: false
    initial_value: '"Steam: --"'
    
  - id: prebrew_label_text
    type: std::string
    restore_value: false
    initial_value: '"PreBrew: --"'
    
  - id: preinfusion_label_text
    type: std::string
    restore_value: false
    initial_value: '"PreInf: --.-s"'
    
  - id: brewing_label_text
    type: std::string
    restore_value: false
    initial_value: '"Brewing: --.-s"'
    
  - id: power_bg_color
    type: int
    restore_value: false
    initial_value: '0x1A1A1A'
  - id: power_border_color
    type: int
    restore_value: false
    initial_value: '0x333333'
  - id: temp_bg_color
    type: int
    restore_value: false
    initial_value: '0x1A1A1A'
  - id: temp_border_color
    type: int
    restore_value: false
    initial_value: '0x333333'
  - id: steam_bg_color
    type: int
    restore_value: false
    initial_value: '0x1A1A1A'
  - id: steam_border_color
    type: int
    restore_value: false
    initial_value: '0x333333'
  - id: prebrew_bg_color
    type: int
    restore_value: false
    initial_value: '0x1A1A1A'
  - id: prebrew_border_color
    type: int
    restore_value: false
    initial_value: '0x333333'
  - id: preinfusion_bg_color
    type: int
    restore_value: false
    initial_value: '0x1A1A1A'
  - id: preinfusion_border_color
    type: int
    restore_value: false
    initial_value: '0x333333'
  - id: brewing_bg_color
    type: int
    restore_value: false
    initial_value: '0x1A1A1A'
  - id: brewing_border_color
    type: int
    restore_value: false
    initial_value: '0x333333'

# LVGL Configuration
lvgl:
  id: my_lvgl
  displays:
    - main_display
  touchscreens:
    - my_touchscreen
  color_depth: 16
  
  pages:
    - id: lamarzocco_page
      widgets:
        # Base background
        - obj:
            id: bg_container
            width: 100%
            height: 100%
            bg_color: 0x000000
            bg_opa: 100%
            border_width: 0
            radius: 0

        # Logo background image
        - image:
            id: lm_logo_background
            src: lm_logo_background_image
            align: CENTER
            width: 100%
            height: 100%
            recolor: 0x333333
            recolor_opa: 80%
            
        # Title
        - label:
            id: title_label
            text: "La Marzocco Micra"
            text_font: roboto_36
            text_color: 0xFFFFFF
            align: TOP_MID
            y: 12
            
        # 1. Power State (selectable)
        - obj:
            id: power_container
            width: 230
            height: 70
            align: CENTER
            y: -120
            bg_color: 0x1A1A1A
            bg_opa: 85%
            border_width: 2
            border_color: 0x333333
            radius: 30
            pad_all: 6
            widgets:
              - label:
                  id: power_label
                  text: !lambda 'return id(power_label_text);'
                  text_font: roboto
                  text_color: 0xFFFFFF
                  align: CENTER
                  width: 100%
                  
        # 2. Coffee Boiler Temperature (selectable)
        - obj:
            id: temp_container
            width: 160
            height: 70
            align: CENTER
            x: -120
            y: -10
            bg_color: 0x1A1A1A
            bg_opa: 85%
            border_width: 2
            border_color: 0x333333
            radius: 30
            pad_all: 6
            widgets:
              - label:
                  id: temp_label
                  text: !lambda 'return id(temp_label_text);'
                  text_font: roboto
                  text_color: 0xFFFFFF
                  align: CENTER
                  width: 100%
                  
        # 3. Steam Power Level (selectable)
        - obj:
            id: steam_container
            width: 160
            height: 70
            align: CENTER
            x: 120
            y: -10
            bg_color: 0x1A1A1A
            bg_opa: 85%
            border_width: 2
            border_color: 0x333333
            radius: 30
            pad_all: 6
            widgets:
              - label:
                  id: steam_label
                  text: !lambda 'return id(steam_label_text);'
                  text_font: roboto
                  text_color: 0xFFFFFF
                  align: CENTER
                  width: 100%
                  
        # 4. Prebrewing Mode (selectable)
        - obj:
            id: prebrew_container
            width: 160
            height: 70
            align: CENTER
            x: -120
            y: 90
            bg_color: 0x1A1A1A
            bg_opa: 85%
            border_width: 2
            border_color: 0x333333
            radius: 30
            pad_all: 6
            widgets:
              - label:
                  id: prebrew_label
                  text: !lambda 'return id(prebrew_label_text);'
                  text_font: roboto
                  text_color: 0xFFFFFF
                  align: CENTER
                  width: 100%
                  
        # 5. PreInfusion Time (selectable)
        - obj:
            id: preinfusion_container
            width: 160
            height: 70
            align: CENTER
            x: 120
            y: 90
            bg_color: 0x1A1A1A
            bg_opa: 85%
            border_width: 2
            border_color: 0x333333
            radius: 30
            pad_all: 6
            widgets:
              - label:
                  id: preinfusion_label
                  text: !lambda 'return id(preinfusion_label_text);'
                  text_font: roboto
                  text_color: 0xFFFFFF
                  align: CENTER
                  width: 100%
                  
        # 6. Brewing Duration (selectable, read-only display)
        - obj:
            id: brewing_container
            width: 200
            height: 70
            align: CENTER
            y: 135
            bg_color: 0x1A1A1A
            bg_opa: 85%
            border_width: 2
            border_color: 0x333333
            radius: 30
            pad_all: 6
            widgets:
              - label:
                  id: brewing_label
                  text: !lambda 'return id(brewing_label_text);'
                  text_font: roboto
                  text_color: 0xFFFFFF
                  align: CENTER
                  width: 100%

# Rotary Encoder and Home Assistant Sensors
sensor:
  # Rotary Encoder
  - platform: rotary_encoder_custom
    name: "Rotary Encoder"
    id: rotary_encoder
    pin_a: 8
    pin_b: 7
    min_value: -10000
    max_value: 10000
    restore_mode: ALWAYS_ZERO
    publish_initial_value: true
    on_clockwise:
      then:
        - script.execute: screentime  # Reactivate backlight
        - if:
            condition:
              lambda: 'return id(selected_element) >= 0;'
            then:
              - script.execute: handle_encoder_cw
    on_anticlockwise:
      then:
        - script.execute: screentime  # Reactivate backlight
        - if:
            condition:
              lambda: 'return id(selected_element) >= 0;'
            then:
              - script.execute: handle_encoder_ccw

  # Coffee boiler temperature
  - platform: homeassistant
    id: lm_coffee_temp_sensor
    entity_id: ${lm_coffee_temp}
    unit_of_measurement: "C"
    accuracy_decimals: 1
    on_value:
      then:
        - lambda: |-
            char buf[32];
            snprintf(buf, sizeof(buf), "Temp: %.1fC", x);
            id(temp_label_text) = std::string(buf);
        - lvgl.label.update:
            id: temp_label
            text: !lambda 'return id(temp_label_text);'
        - script.execute: update_selection_highlight
        # Trigger verification if temp command pending and value matches
        - if:
            condition:
              lambda: 'return id(temp_pending) && fabs(x - id(sent_temp_value)) < 0.05f;'
            then:
              - lambda: |-
                  id(temp_pending) = false;
                  id(verifying_element) = 1;
              - script.execute: verify_ha_update

  # PreInfusion time
  - platform: homeassistant
    id: lm_preinfusion_time_sensor
    entity_id: ${lm_preinfusion_time}
    unit_of_measurement: "s"
    accuracy_decimals: 1
    on_value:
      then:
        - lambda: |-
            char buf[32];
            snprintf(buf, sizeof(buf), "PreInf: %.1fs", x);
            id(preinfusion_label_text) = std::string(buf);
        - lvgl.label.update:
            id: preinfusion_label
            text: !lambda 'return id(preinfusion_label_text);'
        - script.execute: update_selection_highlight
        # Trigger verification if preinfusion command pending and value matches
        - if:
            condition:
              lambda: 'return id(preinfusion_pending) && fabs(x - id(sent_preinfusion_value)) < 0.05f;'
            then:
              - lambda: |-
                  id(preinfusion_pending) = false;
                  id(verifying_element) = 4;
              - script.execute: verify_ha_update

# Home Assistant Sensors - Reading machine state
binary_sensor:
  # Power state (using binary_sensor for switch)
  - platform: homeassistant
    id: lm_power_state
    entity_id: ${lm_power}
    on_state:
      then:
        - lambda: |-
            std::string state_str = x ? "ON" : "OFF";
            char buf[32];
            snprintf(buf, sizeof(buf), "Power: %s", state_str.c_str());
            id(power_label_text) = std::string(buf);
        - lvgl.label.update:
            id: power_label
            text: !lambda 'return id(power_label_text);'
        - script.execute: update_selection_highlight
        # Trigger verification if power command pending
        - if:
            condition:
              lambda: 'return id(power_pending);'
            then:
              - lambda: |-
                  id(power_pending) = false;
                  id(verifying_element) = 0;
              - script.execute: verify_ha_update

# Steam level (using text_sensor for select entity)
text_sensor:
  - platform: homeassistant
    id: lm_steam_level_sensor
    entity_id: ${lm_steam_level}
    on_value:
      then:
        - lambda: |-
            std::string level = x;
            // Values are now "1", "2", "3" directly
            char buf[32];
            snprintf(buf, sizeof(buf), "Steam: %s", level.c_str());
            id(steam_label_text) = std::string(buf);
        - lvgl.label.update:
            id: steam_label
            text: !lambda 'return id(steam_label_text);'
        - script.execute: update_selection_highlight
        # Trigger verification if steam command pending and value matches
        - if:
            condition:
              lambda: 'return id(steam_pending) && id(sent_steam_value) == x;'
            then:
              - lambda: |-
                  id(steam_pending) = false;
                  id(verifying_element) = 2;
              - script.execute: verify_ha_update

  - platform: homeassistant
    id: lm_prebrew_mode_sensor
    entity_id: ${lm_prebrew_mode}
    on_value:
      then:
        - lambda: |-
            char buf[32];
            snprintf(buf, sizeof(buf), "PreBrew: %s", x.c_str());
            id(prebrew_label_text) = std::string(buf);
        - lvgl.label.update:
            id: prebrew_label
            text: !lambda 'return id(prebrew_label_text);'
        - script.execute: update_selection_highlight
        # Trigger verification if prebrew command pending and value matches
        - if:
            condition:
              lambda: 'return id(prebrew_pending) && id(sent_prebrew_value) == x;'
            then:
              - lambda: |-
                  id(prebrew_pending) = false;
                  id(verifying_element) = 3;
              - script.execute: verify_ha_update

  # Machine status (for brewing start time)
  - platform: homeassistant
    id: lm_status_sensor
    entity_id: ${lm_status}
    attribute: brewing_start_time
    on_value:
      then:
        - script.execute: update_brewing_duration

# Time component for brewing duration calculation
time:
  - platform: sntp
    id: time_comp
    timezone: 'America/Winnipeg'  # Update to your timezone
    servers:
      - 0.pool.ntp.org
      - 1.pool.ntp.org
    on_time:
      - cron: '* * * * * *'  # Every second
        then:
          - script.execute: update_brewing_duration
          - script.execute: check_verification_timeouts

# Scripts
script:
  # Handle touch selection
  - id: select_element
    parameters:
      element: int
    then:
      - lambda: |-
          id(selected_element) = element;
          // Set timeout to 3 seconds from now
          auto now = id(time_comp).now();
          id(selection_timeout) = now.timestamp + 3;
          ESP_LOGD("ui", "Selected element %d", element);
          // Initialize working values from current sensor states
          if (element == 1) {
            // Temperature - sync working value with current sensor value
            id(working_temp_value) = id(lm_coffee_temp_sensor).state;
          } else if (element == 4) {
            // Preinfusion time - sync working value with current sensor value
            id(working_preinfusion_value) = id(lm_preinfusion_time_sensor).state;
          }
      - script.execute: update_selection_highlight
      - script.execute: selection_timeout_timer

  # Update selection highlight
  - id: update_selection_highlight
    then:
      - lambda: |-
          const uint32_t accent_bg = 0x4CAF50;
          const uint32_t accent_border = 0xA5FF8A;
          const uint32_t idle_bg = 0x1A1A1A;
          const uint32_t idle_border = 0x333333;
          int sel = id(selected_element);
          // Power container
          id(power_bg_color) = (sel == 0) ? accent_bg : idle_bg;
          id(power_border_color) = (sel == 0) ? accent_border : idle_border;
          // Temp container
          id(temp_bg_color) = (sel == 1) ? accent_bg : idle_bg;
          id(temp_border_color) = (sel == 1) ? accent_border : idle_border;
          // Steam container
          id(steam_bg_color) = (sel == 2) ? accent_bg : idle_bg;
          id(steam_border_color) = (sel == 2) ? accent_border : idle_border;
          // Prebrew container
          id(prebrew_bg_color) = (sel == 3) ? accent_bg : idle_bg;
          id(prebrew_border_color) = (sel == 3) ? accent_border : idle_border;
          // Preinfusion container
          id(preinfusion_bg_color) = (sel == 4) ? accent_bg : idle_bg;
          id(preinfusion_border_color) = (sel == 4) ? accent_border : idle_border;
          // Brewing container
          id(brewing_bg_color) = (sel == 5) ? accent_bg : idle_bg;
          id(brewing_border_color) = (sel == 5) ? accent_border : idle_border;
      - lvgl.obj.update:
          id: power_container
          bg_color: !lambda 'return lv_color_hex(id(power_bg_color));'
          border_color: !lambda 'return lv_color_hex(id(power_border_color));'
      - lvgl.obj.update:
          id: temp_container
          bg_color: !lambda 'return lv_color_hex(id(temp_bg_color));'
          border_color: !lambda 'return lv_color_hex(id(temp_border_color));'
      - lvgl.obj.update:
          id: steam_container
          bg_color: !lambda 'return lv_color_hex(id(steam_bg_color));'
          border_color: !lambda 'return lv_color_hex(id(steam_border_color));'
      - lvgl.obj.update:
          id: prebrew_container
          bg_color: !lambda 'return lv_color_hex(id(prebrew_bg_color));'
          border_color: !lambda 'return lv_color_hex(id(prebrew_border_color));'
      - lvgl.obj.update:
          id: preinfusion_container
          bg_color: !lambda 'return lv_color_hex(id(preinfusion_bg_color));'
          border_color: !lambda 'return lv_color_hex(id(preinfusion_border_color));'
      - lvgl.obj.update:
          id: brewing_container
          bg_color: !lambda 'return lv_color_hex(id(brewing_bg_color));'
          border_color: !lambda 'return lv_color_hex(id(brewing_border_color));'

  # Selection timeout timer
  - id: selection_timeout_timer
    mode: restart
    then:
      - delay: 3s
      - lambda: |-
          // Check if still selected and timeout expired
          auto now = id(time_comp).now();
          if (id(selected_element) >= 0 && now.timestamp >= id(selection_timeout)) {
            id(selected_element) = -1;
            ESP_LOGD("ui", "Selection timeout");
          }
      - if:
          condition:
            lambda: 'return id(selected_element) < 0;'
          then:
            - script.execute: update_selection_highlight

  # Handle encoder clockwise
  - id: handle_encoder_cw
    then:
      - lambda: |-
          int sel = id(selected_element);
          if (sel < 0) return;  // Nothing selected
          
          // Reset timeout
          auto now = id(time_comp).now();
          id(selection_timeout) = now.timestamp + 3;
          
          // Update UI immediately and prepare value for delayed HA command
          if (sel == 0) {
            // Power - toggle immediately (no delay needed for toggle)
            id(handle_power_toggle) = true;
            id(send_ha_command) = true;
          } else if (sel == 1) {
            // Temperature - increase (use working value, not sensor value)
            float new_temp = id(working_temp_value) + 0.1f;
            if (new_temp > 100.0f) new_temp = 100.0f;
            id(working_temp_value) = new_temp;
            id(temp_new_value) = new_temp;
            // Update UI immediately
            char buf[32];
            snprintf(buf, sizeof(buf), "Temp: %.1fC", new_temp);
            id(temp_label_text) = std::string(buf);
            id(handle_temp_change) = true;
            id(send_ha_command) = true;
          } else if (sel == 2) {
            // Steam level - increase
            std::string current = id(lm_steam_level_sensor).state;
            std::string next;
            if (current == "1") next = "2";
            else if (current == "2") next = "3";
            else next = "1";
            id(steam_new_value) = next;
            // Update UI immediately
            char buf[32];
            snprintf(buf, sizeof(buf), "Steam: %s", next.c_str());
            id(steam_label_text) = std::string(buf);
            id(handle_steam_change) = true;
            id(send_ha_command) = true;
          } else if (sel == 3) {
            // Prebrew mode - cycle forward
            std::string current = id(lm_prebrew_mode_sensor).state;
            std::string next;
            if (current == "prebrew") next = "preinfusion";
            else if (current == "preinfusion") next = "disabled";
            else next = "prebrew";
            id(prebrew_new_value) = next;
            // Update UI immediately
            char buf[32];
            snprintf(buf, sizeof(buf), "PreBrew: %s", next.c_str());
            id(prebrew_label_text) = std::string(buf);
            id(handle_prebrew_change) = true;
            id(send_ha_command) = true;
          } else if (sel == 4) {
            // Preinfusion time - increase (use working value, not sensor value)
            float new_time = id(working_preinfusion_value) + 0.1f;
            if (new_time > 25.0f) new_time = 25.0f;
            id(working_preinfusion_value) = new_time;
            id(preinfusion_new_value) = new_time;
            // Update UI immediately
            char buf[32];
            snprintf(buf, sizeof(buf), "PreInf: %.1fs", new_time);
            id(preinfusion_label_text) = std::string(buf);
            id(handle_preinfusion_change) = true;
            id(send_ha_command) = true;
          }
        # Update UI labels immediately
      - lvgl.label.update:
          id: temp_label
          text: !lambda 'return id(temp_label_text);'
      - lvgl.label.update:
          id: steam_label
          text: !lambda 'return id(steam_label_text);'
      - lvgl.label.update:
          id: prebrew_label
          text: !lambda 'return id(prebrew_label_text);'
      - lvgl.label.update:
          id: preinfusion_label
          text: !lambda 'return id(preinfusion_label_text);'
      # Start/restart delayed HA command script
      - script.execute: send_ha_command_delayed

  # Handle encoder counter-clockwise
  - id: handle_encoder_ccw
    then:
      - lambda: |-
          int sel = id(selected_element);
          if (sel < 0) return;  // Nothing selected
          
          // Reset timeout
          auto now = id(time_comp).now();
          id(selection_timeout) = now.timestamp + 3;
          
          // Update UI immediately and prepare value for delayed HA command
          if (sel == 0) {
            // Power - toggle immediately (no delay needed for toggle)
            id(handle_power_toggle) = true;
            id(send_ha_command) = true;
          } else if (sel == 1) {
            // Temperature - decrease (use working value, not sensor value)
            float new_temp = id(working_temp_value) - 0.1f;
            if (new_temp < 80.0f) new_temp = 80.0f;
            id(working_temp_value) = new_temp;
            id(temp_new_value) = new_temp;
            // Update UI immediately
            char buf[32];
            snprintf(buf, sizeof(buf), "Temp: %.1fC", new_temp);
            id(temp_label_text) = std::string(buf);
            id(handle_temp_change) = true;
            id(send_ha_command) = true;
          } else if (sel == 2) {
            // Steam level - decrease
            std::string current = id(lm_steam_level_sensor).state;
            std::string next;
            if (current == "3") next = "2";
            else if (current == "2") next = "1";
            else next = "3";
            id(steam_new_value) = next;
            // Update UI immediately
            char buf[32];
            snprintf(buf, sizeof(buf), "Steam: %s", next.c_str());
            id(steam_label_text) = std::string(buf);
            id(handle_steam_change) = true;
            id(send_ha_command) = true;
          } else if (sel == 3) {
            // Prebrew mode - cycle backward
            std::string current = id(lm_prebrew_mode_sensor).state;
            std::string next;
            if (current == "disabled") next = "preinfusion";
            else if (current == "preinfusion") next = "prebrew";
            else next = "disabled";
            id(prebrew_new_value) = next;
            // Update UI immediately
            char buf[32];
            snprintf(buf, sizeof(buf), "PreBrew: %s", next.c_str());
            id(prebrew_label_text) = std::string(buf);
            id(handle_prebrew_change) = true;
            id(send_ha_command) = true;
          } else if (sel == 4) {
            // Preinfusion time - decrease (use working value, not sensor value)
            float new_time = id(working_preinfusion_value) - 0.1f;
            if (new_time < 1.0f) new_time = 1.0f;
            id(working_preinfusion_value) = new_time;
            id(preinfusion_new_value) = new_time;
            // Update UI immediately
            char buf[32];
            snprintf(buf, sizeof(buf), "PreInf: %.1fs", new_time);
            id(preinfusion_label_text) = std::string(buf);
            id(handle_preinfusion_change) = true;
            id(send_ha_command) = true;
          }
      # Update UI labels immediately
      - lvgl.label.update:
          id: temp_label
          text: !lambda 'return id(temp_label_text);'
      - lvgl.label.update:
          id: steam_label
          text: !lambda 'return id(steam_label_text);'
      - lvgl.label.update:
          id: prebrew_label
          text: !lambda 'return id(prebrew_label_text);'
      - lvgl.label.update:
          id: preinfusion_label
          text: !lambda 'return id(preinfusion_label_text);'
      # Start/restart delayed HA command script
      - script.execute: send_ha_command_delayed

  # Delayed Home Assistant command sender (restart mode - resets delay if encoder keeps turning)
  # This script only executes AFTER the encoder has stopped for 300ms
  # Verification is only called from here, ensuring it only runs after the command is sent
  - id: send_ha_command_delayed
    mode: restart
    then:
      - delay: 300ms  # Wait 300ms after last encoder movement before sending to HA
      - lambda: |-
          // After delay completes, check if we should still send the command
          // If send_ha_command flag is false, encoder was turned again (script restarted)
          // and we should not send this command
          if (!id(send_ha_command)) {
            ESP_LOGD("encoder", "Command cancelled - encoder still turning");
            return;
          }
          // Clear flag to prevent duplicate sends
          id(send_ha_command) = false;
          ESP_LOGD("encoder", "Encoder stopped - sending command to Home Assistant");
      - if:
          condition:
            lambda: 'return id(handle_power_toggle);'
          then:
            - lambda: 'id(handle_power_toggle) = false;'
            - homeassistant.action:
                action: switch.toggle
                data:
                  entity_id: ${lm_power}
      - if:
          condition:
            lambda: 'return id(handle_temp_change);'
          then:
            - lambda: |-
                id(handle_temp_change) = false;
                id(sent_temp_value) = id(temp_new_value);
                id(verifying_element) = 1;  // Temperature element
                id(temp_pending) = true;
                id(temp_timeout_ms) = millis() + 10000;
                ESP_LOGD("verify", "Temp command pending -> %.2f", (double)id(sent_temp_value));
            - homeassistant.action:
                action: number.set_value
                data:
                  entity_id: ${lm_coffee_temp}
                  value: !lambda 'return id(temp_new_value);'
            # Verification will be triggered by sensor on_value callback when HA updates
      - if:
          condition:
            lambda: 'return id(handle_steam_change);'
          then:
            - lambda: |-
                id(handle_steam_change) = false;
                id(sent_steam_value) = id(steam_new_value);
                id(verifying_element) = 2;  // Steam element
                id(steam_pending) = true;
                id(steam_timeout_ms) = millis() + 10000;
                ESP_LOGD("verify", "Steam command pending -> %s", id(sent_steam_value).c_str());
            - homeassistant.action:
                action: select.select_option
                data:
                  entity_id: ${lm_steam_level}
                  option: !lambda 'return id(steam_new_value);'
            # Verification will be triggered by sensor on_value callback when HA updates
      - if:
          condition:
            lambda: 'return id(handle_prebrew_change);'
          then:
            - lambda: |-
                id(handle_prebrew_change) = false;
                id(sent_prebrew_value) = id(prebrew_new_value);
                id(verifying_element) = 3;  // Prebrew element
                id(prebrew_pending) = true;
                id(prebrew_timeout_ms) = millis() + 10000;
                ESP_LOGD("verify", "Prebrew command pending -> %s", id(sent_prebrew_value).c_str());
            - homeassistant.action:
                action: select.select_option
                data:
                  entity_id: ${lm_prebrew_mode}
                  option: !lambda 'return id(prebrew_new_value);'
            # Verification will be triggered by sensor on_value callback when HA updates
      - if:
          condition:
            lambda: 'return id(handle_preinfusion_change);'
          then:
            - lambda: |-
                id(handle_preinfusion_change) = false;
                id(sent_preinfusion_value) = id(preinfusion_new_value);
                id(verifying_element) = 4;  // Preinfusion element
                id(preinfusion_pending) = true;
                id(preinfusion_timeout_ms) = millis() + 10000;
                ESP_LOGD("verify", "Preinfusion command pending -> %.2f", (double)id(sent_preinfusion_value));
            - homeassistant.action:
                action: number.set_value
                data:
                  entity_id: ${lm_preinfusion_time}
                  value: !lambda 'return id(preinfusion_new_value);'
            # Verification will be triggered by sensor on_value callback when HA updates
      - if:
          condition:
            lambda: 'return id(handle_power_toggle);'
          then:
            - lambda: |-
                id(handle_power_toggle) = false;
                id(verifying_element) = 0;  // Power element
                id(power_pending) = true;
                id(power_timeout_ms) = millis() + 10000;
                ESP_LOGD("verify", "Power command pending");
            - homeassistant.action:
                action: switch.toggle
                data:
                  entity_id: ${lm_power}
            # Verification will be triggered by sensor on_state callback when HA updates

  # Verify Home Assistant update and provide visual feedback
  # This script is triggered by sensor callbacks when HA updates the value
  # It verifies the received value matches what we sent, then provides visual feedback
  - id: verify_ha_update
    then:
      - lambda: |-
          int elem = id(verifying_element);
          if (elem < 0) return;  // Not verifying anything
          
          bool verified = false;
          
          if (elem == 0) {
            // Power - just verify it changed (can't easily verify toggle state)
            verified = true;  // Assume success for toggle
            ESP_LOGD("verify", "Power: verified (toggle)");
          } else if (elem == 1) {
            // Temperature - compare sent value with current sensor value
            float sent = id(sent_temp_value);
            float current = id(lm_coffee_temp_sensor).state;
            // Allow small floating point differences
            verified = (fabs(sent - current) < 0.15f);
            ESP_LOGD("verify", "Temp: sent=%.1f, current=%.1f, verified=%d", sent, current, verified);
          } else if (elem == 2) {
            // Steam level - compare sent value with current sensor value
            std::string sent = id(sent_steam_value);
            std::string current = id(lm_steam_level_sensor).state;
            // Values are now "1", "2", "3" directly
            verified = (sent == current);
            ESP_LOGD("verify", "Steam: sent=%s, current=%s, verified=%d", sent.c_str(), current.c_str(), verified);
          } else if (elem == 3) {
            // Prebrew mode - compare sent value with current sensor value
            std::string sent = id(sent_prebrew_value);
            std::string current = id(lm_prebrew_mode_sensor).state;
            verified = (sent == current);
            ESP_LOGD("verify", "Prebrew: sent=%s, current=%s, verified=%d", sent.c_str(), current.c_str(), verified);
          } else if (elem == 4) {
            // Preinfusion time - compare sent value with current sensor value
            float sent = id(sent_preinfusion_value);
            float current = id(lm_preinfusion_time_sensor).state;
            verified = (fabs(sent - current) < 0.15f);
            ESP_LOGD("verify", "Preinfusion: sent=%.1f, current=%.1f, verified=%d", sent, current, verified);
          }
          
          if (verified) {
            id(verification_success) = true;
          } else {
            ESP_LOGD("verify", "Verification failed - values don't match");
          }
      - if:
          condition:
            lambda: 'return id(verification_success);'
          then:
            - lambda: |-
                id(verification_success) = false;
                int elem = id(verifying_element);
                if (elem < 0) return;
                ESP_LOGD("verify", "Showing green flash for element %d", elem);
                
                // Deselect the element first
                id(selected_element) = -1;
            # Reset selection highlight first
            - script.execute: update_selection_highlight
            - lambda: |-
                int elem = id(verifying_element);
                // Now show green border flash
            # Update LVGL objects directly to show green border
            - if:
                condition:
                  lambda: 'return id(verifying_element) == 0;'
                then:
                  - lvgl.obj.update:
                      id: power_container
                      border_color: !lambda 'return lv_color_hex(0x00FF00);'
            - if:
                condition:
                  lambda: 'return id(verifying_element) == 1;'
                then:
                  - lvgl.obj.update:
                      id: temp_container
                      border_color: !lambda 'return lv_color_hex(0x00FF00);'
            - if:
                condition:
                  lambda: 'return id(verifying_element) == 2;'
                then:
                  - lvgl.obj.update:
                      id: steam_container
                      border_color: !lambda 'return lv_color_hex(0x00FF00);'
            - if:
                condition:
                  lambda: 'return id(verifying_element) == 3;'
                then:
                  - lvgl.obj.update:
                      id: prebrew_container
                      border_color: !lambda 'return lv_color_hex(0x00FF00);'
            - if:
                condition:
                  lambda: 'return id(verifying_element) == 4;'
                then:
                  - lvgl.obj.update:
                      id: preinfusion_container
                      border_color: !lambda 'return lv_color_hex(0x00FF00);'
            - delay: 500ms  # Show green border for 500ms
            - lambda: |-
                // Clear verifying element
                int elem = id(verifying_element);
                id(verifying_element) = -1;
                ESP_LOGD("verify", "Clearing verification for element %d", elem);
            # Reset to normal colors using update_selection_highlight
            - script.execute: update_selection_highlight
      - if:
          condition:
            lambda: 'return !id(verification_success) && id(verifying_element) >= 0;'
          then:
            - lambda: |-
                // Verification failed - values don't match
                ESP_LOGD("verify", "Verification failed - values don't match");
                // Still deselect but without green flash
                id(selected_element) = -1;
                id(verifying_element) = -1;
            - script.execute: update_selection_highlight
  # Periodic timeout checker for pending verifications
  - id: check_verification_timeouts
    then:
      - lambda: |-
          uint32_t now = millis();
          auto check_timeout = [&](bool &pending, uint32_t &deadline, const char *name) {
            if (pending) {
              int32_t remaining = static_cast<int32_t>(deadline - now);
              if (remaining <= 0) {
                ESP_LOGW("verify", "%s command timed out", name);
                pending = false;
              }
            }
          };
          check_timeout(id(power_pending), id(power_timeout_ms), "Power");
          check_timeout(id(temp_pending), id(temp_timeout_ms), "Temp");
          check_timeout(id(steam_pending), id(steam_timeout_ms), "Steam");
          check_timeout(id(prebrew_pending), id(prebrew_timeout_ms), "Prebrew");
          check_timeout(id(preinfusion_pending), id(preinfusion_timeout_ms), "Preinfusion");

  # Initialize UI values from Home Assistant on boot
  - id: initialize_ui_values
    then:
      - lambda: |-
          // Trigger sensor updates by reading their state
          // The sensors will update the labels via their on_value handlers
          ESP_LOGD("init", "Initializing UI values from Home Assistant");
          // Force update by reading current state
          float temp = id(lm_coffee_temp_sensor).state;
          float preinf = id(lm_preinfusion_time_sensor).state;
          bool power = id(lm_power_state).state;
          std::string steam = id(lm_steam_level_sensor).state;
          std::string prebrew = id(lm_prebrew_mode_sensor).state;
          
          // Update labels manually if sensors haven't fired yet
          if (temp > 0) {
            char buf[32];
            snprintf(buf, sizeof(buf), "Temp: %.1fC", temp);
            id(temp_label_text) = std::string(buf);
          }
          if (preinf > 0) {
            char buf[32];
            snprintf(buf, sizeof(buf), "PreInf: %.1fs", preinf);
            id(preinfusion_label_text) = std::string(buf);
          }
          {
            std::string state_str = power ? "ON" : "OFF";
            char buf[32];
            snprintf(buf, sizeof(buf), "Power: %s", state_str.c_str());
            id(power_label_text) = std::string(buf);
          }
          if (!steam.empty()) {
            char buf[32];
            snprintf(buf, sizeof(buf), "Steam: %s", steam.c_str());
            id(steam_label_text) = std::string(buf);
          }
          if (!prebrew.empty()) {
            char buf[32];
            snprintf(buf, sizeof(buf), "PreBrew: %s", prebrew.c_str());
            id(prebrew_label_text) = std::string(buf);
          }
      - lvgl.label.update:
          id: temp_label
          text: !lambda 'return id(temp_label_text);'
      - lvgl.label.update:
          id: preinfusion_label
          text: !lambda 'return id(preinfusion_label_text);'
      - lvgl.label.update:
          id: power_label
          text: !lambda 'return id(power_label_text);'
      - lvgl.label.update:
          id: steam_label
          text: !lambda 'return id(steam_label_text);'
      - lvgl.label.update:
          id: prebrew_label
          text: !lambda 'return id(prebrew_label_text);'

  # Update brewing duration
  - id: update_brewing_duration
    then:
      - lambda: |-
          std::string start_time_str = id(lm_status_sensor).state;
          if (start_time_str.empty() || start_time_str == "null" || start_time_str == "unknown" || start_time_str == "None") {
            id(brewing_duration) = 0.0f;
            id(brewing_label_text) = "Brewing: --.-s";
          } else {
            // Increment brewing duration by 0.1s each second
            // Note: This is a simplified approach. For accurate timing, you'd need to parse
            // the ISO 8601 timestamp and calculate the actual difference
            float duration = id(brewing_duration) + 0.1f;
            
            char buf[32];
            snprintf(buf, sizeof(buf), "Brewing: %.1fs", duration);
            id(brewing_label_text) = std::string(buf);
            id(brewing_duration) = duration;
          }
      - lvgl.label.update:
          id: brewing_label
          text: !lambda 'return id(brewing_label_text);'

# Touch screen handlers are in waveshare.yaml, but we add element selection here
# We'll use a lambda in the touchscreen on_touch to call our script

