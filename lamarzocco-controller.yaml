substitutions:
  # La Marzocco entity IDs - update these to match your Home Assistant setup
  # These are typically auto-discovered by the La Marzocco integration
  lm_entity: "lamarzocco.micra"  # Update to your actual entity ID
  lm_power: "switch.micra"  # Update if different
  lm_coffee_temp: "number.micra_coffee_target_temperature"  # Update if different
  lm_steam_level: "select.micra_steam_level"  # Update if different
  lm_prebrew_mode: "select.micra_prebrew_infusion_mode"  # Update if different
  lm_preinfusion_time: "number.micra_preinfusion_time"  # Update if different
  lm_status: "binary_sensor.micra_brewing_active"  # Update if different
  lm_brewing_start: "sensor.micra_brewing_start_time"  # Update if different

esphome:
  name: lamarzocco-controller
  on_boot:
    priority: 200
    then:
      - delay: 5s  # Wait for Home Assistant connection
      - script.execute: initialize_ui_values

packages:
#remote package files are necessary - DO NOT REMOVE
  remote_package_files:
    url: https://github.com/donnyb999/WaveShare-Knob-Esp32S3
    files: [lamarzocco/waveshare.yaml,lamarzocco/esp-config.yaml,lamarzocco/ha-config.yaml] 
#  lvgl: !include lamarzocco/lvgl.yaml

# External component for ST77916 display
external_components:
  - source:
      type: git
      url: https://github.com/donnyb999/WaveShare-Knob-Esp32S3
      ref: main
    refresh: always
    
  - source: github://pr#10392
    components: [mipi_spi]
    refresh: 1d

# Font definition
font:
  - file: "gfonts://Roboto"
    id: roboto_small
    size: 16
  - file: "gfonts://Roboto"
    id: roboto
    size: 20
  - file: "gfonts://Roboto"
    id: roboto_28
    size: 28
  - file: "gfonts://Roboto"
    id: roboto_36
    size: 36
  - file: "gfonts://Roboto"
    id: roboto_48
    size: 48

# Global variables for UI state
globals:
  - id: selected_element
    type: int
    restore_value: false
    initial_value: '-1'  # -1 = nothing selected, 0-5 = element indices
    
  - id: selection_timeout
    type: int
    restore_value: false
    initial_value: '0'  # Timestamp when selection expires
    
  - id: brewing_duration
    type: float
    restore_value: false
    initial_value: '0.0'  # Current brewing duration in seconds
    
  - id: temp_new_value
    type: float
    restore_value: false
    initial_value: '89.0'
    
  - id: steam_new_value
    type: std::string
    restore_value: false
    #initial_value: ""
    
  - id: prebrew_new_value
    type: std::string
    restore_value: false
    #initial_value: ""
    
  - id: preinfusion_new_value
    type: float
    restore_value: false
    initial_value: '7.3'
  
  # Working values for encoder adjustments (accumulate changes locally)
  - id: working_temp_value
    type: float
    restore_value: false
    initial_value: '89.0'
  - id: working_preinfusion_value
    type: float
    restore_value: false
    initial_value: '7.3'
    
  - id: handle_power_toggle
    type: bool
    restore_value: false
    initial_value: 'false'
  - id: handle_temp_change
    type: bool
    restore_value: false
    initial_value: 'false'
  - id: handle_steam_change
    type: bool
    restore_value: false
    initial_value: 'false'
  - id: handle_prebrew_change
    type: bool
    restore_value: false
    initial_value: 'false'
  - id: handle_preinfusion_change
    type: bool
    restore_value: false
    initial_value: 'false'
  - id: send_ha_command
    type: bool
    restore_value: false
    initial_value: 'false'
  
  # Verification tracking
  - id: verifying_element
    type: int
    restore_value: false
    initial_value: '-1'  # -1 = not verifying, 0-5 = element index
  - id: sent_temp_value
    type: float
    restore_value: false
    initial_value: '0.0'
  - id: sent_preinfusion_value
    type: float
    restore_value: false
    initial_value: '0.0'
  - id: sent_steam_value
    type: std::string
    restore_value: false
    #initial_value: ""
  - id: sent_prebrew_value
    type: std::string
    restore_value: false
    #initial_value: ""
    
  - id: power_label_text
    type: std::string
    restore_value: false
    initial_value: '"Power: OFF"'
    
  - id: temp_label_text
    type: std::string
    restore_value: false
    initial_value: '"Temp: --.-C"'
    
  - id: steam_label_text
    type: std::string
    restore_value: false
    initial_value: '"Steam: --"'
    
  - id: prebrew_label_text
    type: std::string
    restore_value: false
    initial_value: '"PreBrew: --"'
    
  - id: preinfusion_label_text
    type: std::string
    restore_value: false
    initial_value: '"PreInf: --.-s"'
    
  - id: brewing_label_text
    type: std::string
    restore_value: false
    initial_value: '"Brewing: --.-s"'
    
  - id: power_bg_color
    type: int
    restore_value: false
    initial_value: '0xE0E0E0'
  - id: power_border_color
    type: int
    restore_value: false
    initial_value: '0x000000'
  - id: temp_bg_color
    type: int
    restore_value: false
    initial_value: '0xE0E0E0'
  - id: temp_border_color
    type: int
    restore_value: false
    initial_value: '0x000000'
  - id: steam_bg_color
    type: int
    restore_value: false
    initial_value: '0xE0E0E0'
  - id: steam_border_color
    type: int
    restore_value: false
    initial_value: '0x000000'
  - id: prebrew_bg_color
    type: int
    restore_value: false
    initial_value: '0xE0E0E0'
  - id: prebrew_border_color
    type: int
    restore_value: false
    initial_value: '0x000000'
  - id: preinfusion_bg_color
    type: int
    restore_value: false
    initial_value: '0xE0E0E0'
  - id: preinfusion_border_color
    type: int
    restore_value: false
    initial_value: '0x000000'
  - id: brewing_bg_color
    type: int
    restore_value: false
    initial_value: '0xE0E0E0'
  - id: brewing_border_color
    type: int
    restore_value: false
    initial_value: '0x000000'

# LVGL Configuration
lvgl:
  id: my_lvgl
  displays:
    - main_display
  touchscreens:
    - my_touchscreen
  color_depth: 16
  
  pages:
    - id: lamarzocco_page
      widgets:
        # Background
        - obj:
            id: bg_container
            width: 100%
            height: 100%
            bg_color: 0xFFFFFF
            border_width: 0
            
        # Title
        - label:
            id: title_label
            text: "La Marzocco Micra"
            text_font: roboto_36
            text_color: 0x000000
            align: TOP_MID
            y: 10
            
        # 1. Power State (selectable)
        - obj:
            id: power_container
            width: 90%
            height: 50
            align: TOP_LEFT
            x: 5%
            y: 60
            bg_color: 0xE0E0E0
            border_width: 2
            border_color: 0x000000
            radius: 5
            widgets:
              - label:
                  id: power_label
                  text: !lambda 'return id(power_label_text);'
                  text_font: roboto
                  text_color: 0x000000
                  align: CENTER
                  
        # 2. Coffee Boiler Temperature (selectable)
        - obj:
            id: temp_container
            width: 90%
            height: 50
            align: TOP_LEFT
            x: 5%
            y: 120
            bg_color: 0xE0E0E0
            border_width: 2
            border_color: 0x000000
            radius: 5
            widgets:
              - label:
                  id: temp_label
                  text: !lambda 'return id(temp_label_text);'
                  text_font: roboto
                  text_color: 0x000000
                  align: CENTER
                  
        # 3. Steam Power Level (selectable)
        - obj:
            id: steam_container
            width: 90%
            height: 50
            align: TOP_LEFT
            x: 5%
            y: 180
            bg_color: 0xE0E0E0
            border_width: 2
            border_color: 0x000000
            radius: 5
            widgets:
              - label:
                  id: steam_label
                  text: !lambda 'return id(steam_label_text);'
                  text_font: roboto
                  text_color: 0x000000
                  align: CENTER
                  
        # 4. Prebrewing Mode (selectable)
        - obj:
            id: prebrew_container
            width: 90%
            height: 50
            align: TOP_LEFT
            x: 5%
            y: 240
            bg_color: 0xE0E0E0
            border_width: 2
            border_color: 0x000000
            radius: 5
            widgets:
              - label:
                  id: prebrew_label
                  text: !lambda 'return id(prebrew_label_text);'
                  text_font: roboto
                  text_color: 0x000000
                  align: CENTER
                  
        # 5. PreInfusion Time (selectable)
        - obj:
            id: preinfusion_container
            width: 90%
            height: 50
            align: TOP_LEFT
            x: 5%
            y: 300
            bg_color: 0xE0E0E0
            border_width: 2
            border_color: 0x000000
            radius: 5
            widgets:
              - label:
                  id: preinfusion_label
                  text: !lambda 'return id(preinfusion_label_text);'
                  text_font: roboto
                  text_color: 0x000000
                  align: CENTER
                  
        # 6. Brewing Duration (selectable, read-only display)
        - obj:
            id: brewing_container
            width: 90%
            height: 50
            align: TOP_LEFT
            x: 5%
            y: 360
            bg_color: 0xE0E0E0
            border_width: 2
            border_color: 0x000000
            radius: 5
            widgets:
              - label:
                  id: brewing_label
                  text: !lambda 'return id(brewing_label_text);'
                  text_font: roboto
                  text_color: 0x000000
                  align: CENTER

# Rotary Encoder and Home Assistant Sensors
sensor:
  # Rotary Encoder
  - platform: rotary_encoder_custom
    name: "Rotary Encoder"
    id: rotary_encoder
    pin_a: 8
    pin_b: 7
    min_value: -10000
    max_value: 10000
    restore_mode: ALWAYS_ZERO
    publish_initial_value: true
    on_clockwise:
      then:
        - script.execute: screentime  # Reactivate backlight
        - if:
            condition:
              lambda: 'return id(selected_element) >= 0;'
            then:
              - script.execute: handle_encoder_cw
    on_anticlockwise:
      then:
        - script.execute: screentime  # Reactivate backlight
        - if:
            condition:
              lambda: 'return id(selected_element) >= 0;'
            then:
              - script.execute: handle_encoder_ccw

  # Coffee boiler temperature
  - platform: homeassistant
    id: lm_coffee_temp_sensor
    entity_id: ${lm_coffee_temp}
    unit_of_measurement: "C"
    accuracy_decimals: 1
    on_value:
      then:
        - lambda: |-
            char buf[32];
            snprintf(buf, sizeof(buf), "Temp: %.1fC", x);
            id(temp_label_text) = std::string(buf);
        - lvgl.label.update:
            id: temp_label
            text: !lambda 'return id(temp_label_text);'
        - script.execute: update_selection_highlight

  # PreInfusion time
  - platform: homeassistant
    id: lm_preinfusion_time_sensor
    entity_id: ${lm_preinfusion_time}
    unit_of_measurement: "s"
    accuracy_decimals: 1
    on_value:
      then:
        - lambda: |-
            char buf[32];
            snprintf(buf, sizeof(buf), "PreInf: %.1fs", x);
            id(preinfusion_label_text) = std::string(buf);
        - lvgl.label.update:
            id: preinfusion_label
            text: !lambda 'return id(preinfusion_label_text);'
        - script.execute: update_selection_highlight

# Home Assistant Sensors - Reading machine state
binary_sensor:
  # Power state (using binary_sensor for switch)
  - platform: homeassistant
    id: lm_power_state
    entity_id: ${lm_power}
    on_state:
      then:
        - lambda: |-
            std::string state_str = x ? "ON" : "OFF";
            char buf[32];
            snprintf(buf, sizeof(buf), "Power: %s", state_str.c_str());
            id(power_label_text) = std::string(buf);
        - lvgl.label.update:
            id: power_label
            text: !lambda 'return id(power_label_text);'
        - script.execute: update_selection_highlight

# Steam level (using text_sensor for select entity)
text_sensor:
  - platform: homeassistant
    id: lm_steam_level_sensor
    entity_id: ${lm_steam_level}
    on_value:
      then:
        - lambda: |-
            std::string level = x;
            // Extract level number from "Level1", "Level2", "Level3"
            std::string level_num = level.length() > 5 ? level.substr(5) : level;
            char buf[32];
            snprintf(buf, sizeof(buf), "Steam: %s", level_num.c_str());
            id(steam_label_text) = std::string(buf);
        - lvgl.label.update:
            id: steam_label
            text: !lambda 'return id(steam_label_text);'
        - script.execute: update_selection_highlight

  - platform: homeassistant
    id: lm_prebrew_mode_sensor
    entity_id: ${lm_prebrew_mode}
    on_value:
      then:
        - lambda: |-
            char buf[32];
            snprintf(buf, sizeof(buf), "PreBrew: %s", x.c_str());
            id(prebrew_label_text) = std::string(buf);
        - lvgl.label.update:
            id: prebrew_label
            text: !lambda 'return id(prebrew_label_text);'
        - script.execute: update_selection_highlight

  # Machine status (for brewing start time)
  - platform: homeassistant
    id: lm_status_sensor
    entity_id: ${lm_status}
    attribute: brewing_start_time
    on_value:
      then:
        - script.execute: update_brewing_duration

# Time component for brewing duration calculation
time:
  - platform: sntp
    id: time_comp
    timezone: 'America/Winnipeg'  # Update to your timezone
    servers:
      - 0.pool.ntp.org
      - 1.pool.ntp.org
    on_time:
      - cron: '* * * * * *'  # Every second
        then:
          - script.execute: update_brewing_duration

# Scripts
script:
  # Handle touch selection
  - id: select_element
    parameters:
      element: int
    then:
      - lambda: |-
          id(selected_element) = element;
          // Set timeout to 3 seconds from now
          auto now = id(time_comp).now();
          id(selection_timeout) = now.timestamp + 3;
          ESP_LOGD("ui", "Selected element %d", element);
          // Initialize working values from current sensor states
          if (element == 1) {
            // Temperature - sync working value with current sensor value
            id(working_temp_value) = id(lm_coffee_temp_sensor).state;
          } else if (element == 4) {
            // Preinfusion time - sync working value with current sensor value
            id(working_preinfusion_value) = id(lm_preinfusion_time_sensor).state;
          }
      - script.execute: update_selection_highlight
      - script.execute: selection_timeout_timer

  # Update selection highlight
  - id: update_selection_highlight
    then:
      - lambda: |-
          int sel = id(selected_element);
          // Set colors for each container based on selection
          // Power container
          id(power_bg_color) = (sel == 0) ? 0x00BFFF : 0xE0E0E0;
          id(power_border_color) = (sel == 0) ? 0x0000FF : 0x000000;
          // Temp container
          id(temp_bg_color) = (sel == 1) ? 0x00BFFF : 0xE0E0E0;
          id(temp_border_color) = (sel == 1) ? 0x0000FF : 0x000000;
          // Steam container
          id(steam_bg_color) = (sel == 2) ? 0x00BFFF : 0xE0E0E0;
          id(steam_border_color) = (sel == 2) ? 0x0000FF : 0x000000;
          // Prebrew container
          id(prebrew_bg_color) = (sel == 3) ? 0x00BFFF : 0xE0E0E0;
          id(prebrew_border_color) = (sel == 3) ? 0x0000FF : 0x000000;
          // Preinfusion container
          id(preinfusion_bg_color) = (sel == 4) ? 0x00BFFF : 0xE0E0E0;
          id(preinfusion_border_color) = (sel == 4) ? 0x0000FF : 0x000000;
          // Brewing container
          id(brewing_bg_color) = (sel == 5) ? 0x00BFFF : 0xE0E0E0;
          id(brewing_border_color) = (sel == 5) ? 0x0000FF : 0x000000;
      - lvgl.obj.update:
          id: power_container
          bg_color: !lambda 'return lv_color_hex(id(power_bg_color));'
          border_color: !lambda 'return lv_color_hex(id(power_border_color));'
      - lvgl.obj.update:
          id: temp_container
          bg_color: !lambda 'return lv_color_hex(id(temp_bg_color));'
          border_color: !lambda 'return lv_color_hex(id(temp_border_color));'
      - lvgl.obj.update:
          id: steam_container
          bg_color: !lambda 'return lv_color_hex(id(steam_bg_color));'
          border_color: !lambda 'return lv_color_hex(id(steam_border_color));'
      - lvgl.obj.update:
          id: prebrew_container
          bg_color: !lambda 'return lv_color_hex(id(prebrew_bg_color));'
          border_color: !lambda 'return lv_color_hex(id(prebrew_border_color));'
      - lvgl.obj.update:
          id: preinfusion_container
          bg_color: !lambda 'return lv_color_hex(id(preinfusion_bg_color));'
          border_color: !lambda 'return lv_color_hex(id(preinfusion_border_color));'
      - lvgl.obj.update:
          id: brewing_container
          bg_color: !lambda 'return lv_color_hex(id(brewing_bg_color));'
          border_color: !lambda 'return lv_color_hex(id(brewing_border_color));'

  # Selection timeout timer
  - id: selection_timeout_timer
    mode: restart
    then:
      - delay: 3s
      - lambda: |-
          // Check if still selected and timeout expired
          auto now = id(time_comp).now();
          if (id(selected_element) >= 0 && now.timestamp >= id(selection_timeout)) {
            id(selected_element) = -1;
            ESP_LOGD("ui", "Selection timeout");
          }
      - if:
          condition:
            lambda: 'return id(selected_element) < 0;'
          then:
            - script.execute: update_selection_highlight

  # Handle encoder clockwise
  - id: handle_encoder_cw
    then:
      - lambda: |-
          int sel = id(selected_element);
          if (sel < 0) return;  // Nothing selected
          
          // Reset timeout
          auto now = id(time_comp).now();
          id(selection_timeout) = now.timestamp + 3;
          
          // Update UI immediately and prepare value for delayed HA command
          if (sel == 0) {
            // Power - toggle immediately (no delay needed for toggle)
            id(handle_power_toggle) = true;
            id(send_ha_command) = true;
          } else if (sel == 1) {
            // Temperature - increase (use working value, not sensor value)
            float new_temp = id(working_temp_value) + 0.1f;
            if (new_temp > 100.0f) new_temp = 100.0f;
            id(working_temp_value) = new_temp;
            id(temp_new_value) = new_temp;
            // Update UI immediately
            char buf[32];
            snprintf(buf, sizeof(buf), "Temp: %.1fC", new_temp);
            id(temp_label_text) = std::string(buf);
            id(handle_temp_change) = true;
            id(send_ha_command) = true;
          } else if (sel == 2) {
            // Steam level - increase
            std::string current = id(lm_steam_level_sensor).state;
            std::string next;
            if (current == "1") next = "2";
            else if (current == "2") next = "3";
            else next = "1";
            id(steam_new_value) = next;
            // Update UI immediately
            std::string level_num = next.length() > 5 ? next.substr(5) : next;
            char buf[32];
            snprintf(buf, sizeof(buf), "Steam: %s", level_num.c_str());
            id(steam_label_text) = std::string(buf);
            id(handle_steam_change) = true;
            id(send_ha_command) = true;
          } else if (sel == 3) {
            // Prebrew mode - cycle forward
            std::string current = id(lm_prebrew_mode_sensor).state;
            std::string next;
            if (current == "prebrew") next = "preinfusion";
            else if (current == "preinfusion") next = "disabled";
            else next = "prebrew";
            id(prebrew_new_value) = next;
            // Update UI immediately
            char buf[32];
            snprintf(buf, sizeof(buf), "PreBrew: %s", next.c_str());
            id(prebrew_label_text) = std::string(buf);
            id(handle_prebrew_change) = true;
            id(send_ha_command) = true;
          } else if (sel == 4) {
            // Preinfusion time - increase (use working value, not sensor value)
            float new_time = id(working_preinfusion_value) + 0.1f;
            if (new_time > 25.0f) new_time = 25.0f;
            id(working_preinfusion_value) = new_time;
            id(preinfusion_new_value) = new_time;
            // Update UI immediately
            char buf[32];
            snprintf(buf, sizeof(buf), "PreInf: %.1fs", new_time);
            id(preinfusion_label_text) = std::string(buf);
            id(handle_preinfusion_change) = true;
            id(send_ha_command) = true;
          }
        # Update UI labels immediately
      - lvgl.label.update:
          id: temp_label
          text: !lambda 'return id(temp_label_text);'
      - lvgl.label.update:
          id: steam_label
          text: !lambda 'return id(steam_label_text);'
      - lvgl.label.update:
          id: prebrew_label
          text: !lambda 'return id(prebrew_label_text);'
      - lvgl.label.update:
          id: preinfusion_label
          text: !lambda 'return id(preinfusion_label_text);'
      # Start/restart delayed HA command script
      - script.execute: send_ha_command_delayed

  # Handle encoder counter-clockwise
  - id: handle_encoder_ccw
    then:
      - lambda: |-
          int sel = id(selected_element);
          if (sel < 0) return;  // Nothing selected
          
          // Reset timeout
          auto now = id(time_comp).now();
          id(selection_timeout) = now.timestamp + 3;
          
          // Update UI immediately and prepare value for delayed HA command
          if (sel == 0) {
            // Power - toggle immediately (no delay needed for toggle)
            id(handle_power_toggle) = true;
            id(send_ha_command) = true;
          } else if (sel == 1) {
            // Temperature - decrease (use working value, not sensor value)
            float new_temp = id(working_temp_value) - 0.1f;
            if (new_temp < 80.0f) new_temp = 80.0f;
            id(working_temp_value) = new_temp;
            id(temp_new_value) = new_temp;
            // Update UI immediately
            char buf[32];
            snprintf(buf, sizeof(buf), "Temp: %.1fC", new_temp);
            id(temp_label_text) = std::string(buf);
            id(handle_temp_change) = true;
            id(send_ha_command) = true;
          } else if (sel == 2) {
            // Steam level - decrease
            std::string current = id(lm_steam_level_sensor).state;
            std::string next;
            if (current == "3") next = "2";
            else if (current == "2") next = "1";
            else next = "3";
            id(steam_new_value) = next;
            // Update UI immediately
            std::string level_num = next.length() > 5 ? next.substr(5) : next;
            char buf[32];
            snprintf(buf, sizeof(buf), "Steam: %s", level_num.c_str());
            id(steam_label_text) = std::string(buf);
            id(handle_steam_change) = true;
            id(send_ha_command) = true;
          } else if (sel == 3) {
            // Prebrew mode - cycle backward
            std::string current = id(lm_prebrew_mode_sensor).state;
            std::string next;
            if (current == "disabled") next = "preinfusion";
            else if (current == "preinfusion") next = "prebrew";
            else next = "disabled";
            id(prebrew_new_value) = next;
            // Update UI immediately
            char buf[32];
            snprintf(buf, sizeof(buf), "PreBrew: %s", next.c_str());
            id(prebrew_label_text) = std::string(buf);
            id(handle_prebrew_change) = true;
            id(send_ha_command) = true;
          } else if (sel == 4) {
            // Preinfusion time - decrease (use working value, not sensor value)
            float new_time = id(working_preinfusion_value) - 0.1f;
            if (new_time < 1.0f) new_time = 1.0f;
            id(working_preinfusion_value) = new_time;
            id(preinfusion_new_value) = new_time;
            // Update UI immediately
            char buf[32];
            snprintf(buf, sizeof(buf), "PreInf: %.1fs", new_time);
            id(preinfusion_label_text) = std::string(buf);
            id(handle_preinfusion_change) = true;
            id(send_ha_command) = true;
          }
      # Update UI labels immediately
      - lvgl.label.update:
          id: temp_label
          text: !lambda 'return id(temp_label_text);'
      - lvgl.label.update:
          id: steam_label
          text: !lambda 'return id(steam_label_text);'
      - lvgl.label.update:
          id: prebrew_label
          text: !lambda 'return id(prebrew_label_text);'
      - lvgl.label.update:
          id: preinfusion_label
          text: !lambda 'return id(preinfusion_label_text);'
      # Start/restart delayed HA command script
      - script.execute: send_ha_command_delayed

  # Delayed Home Assistant command sender (restart mode - resets delay if encoder keeps turning)
  - id: send_ha_command_delayed
    mode: restart
    then:
      - delay: 500ms  # Wait 500ms after last encoder movement before sending to HA
      - lambda: |-
          // After delay, check if we should still send the command
          // If send_ha_command flag is false, encoder was turned again (script restarted)
          // and we should not send this command
          if (!id(send_ha_command)) {
            ESP_LOGD("encoder", "Command cancelled - encoder still turning");
            return;
          }
          // Clear flag to prevent duplicate sends
          id(send_ha_command) = false;
          ESP_LOGD("encoder", "Sending delayed command to Home Assistant");
      - if:
          condition:
            lambda: 'return id(handle_power_toggle);'
          then:
            - lambda: 'id(handle_power_toggle) = false;'
            - homeassistant.action:
                action: switch.toggle
                data:
                  entity_id: ${lm_power}
      - if:
          condition:
            lambda: 'return id(handle_temp_change);'
          then:
            - lambda: |-
                id(handle_temp_change) = false;
                id(sent_temp_value) = id(temp_new_value);
                id(verifying_element) = 1;  // Temperature element
            - homeassistant.action:
                action: number.set_value
                data:
                  entity_id: ${lm_coffee_temp}
                  value: !lambda 'return id(temp_new_value);'
            - script.execute: verify_ha_update
      - if:
          condition:
            lambda: 'return id(handle_steam_change);'
          then:
            - lambda: |-
                id(handle_steam_change) = false;
                id(sent_steam_value) = id(steam_new_value);
                id(verifying_element) = 2;  // Steam element
            - homeassistant.action:
                action: select.select_option
                data:
                  entity_id: ${lm_steam_level}
                  option: !lambda 'return id(steam_new_value);'
            - script.execute: verify_ha_update
      - if:
          condition:
            lambda: 'return id(handle_prebrew_change);'
          then:
            - lambda: |-
                id(handle_prebrew_change) = false;
                id(sent_prebrew_value) = id(prebrew_new_value);
                id(verifying_element) = 3;  // Prebrew element
            - homeassistant.action:
                action: select.select_option
                data:
                  entity_id: ${lm_prebrew_mode}
                  option: !lambda 'return id(prebrew_new_value);'
            - script.execute: verify_ha_update
      - if:
          condition:
            lambda: 'return id(handle_preinfusion_change);'
          then:
            - lambda: |-
                id(handle_preinfusion_change) = false;
                id(sent_preinfusion_value) = id(preinfusion_new_value);
                id(verifying_element) = 4;  // Preinfusion element
            - homeassistant.action:
                action: number.set_value
                data:
                  entity_id: ${lm_preinfusion_time}
                  value: !lambda 'return id(preinfusion_new_value);'
            - script.execute: verify_ha_update
      - if:
          condition:
            lambda: 'return id(handle_power_toggle);'
          then:
            - lambda: |-
                id(handle_power_toggle) = false;
                id(verifying_element) = 0;  // Power element
            - homeassistant.action:
                action: switch.toggle
                data:
                  entity_id: ${lm_power}
            - script.execute: verify_ha_update

  # Initialize UI values from Home Assistant on boot
  - id: initialize_ui_values
    then:
      - lambda: |-
          // Trigger sensor updates by reading their state
          // The sensors will update the labels via their on_value handlers
          ESP_LOGD("init", "Initializing UI values from Home Assistant");
          // Force update by reading current state
          float temp = id(lm_coffee_temp_sensor).state;
          float preinf = id(lm_preinfusion_time_sensor).state;
          bool power = id(lm_power_state).state;
          std::string steam = id(lm_steam_level_sensor).state;
          std::string prebrew = id(lm_prebrew_mode_sensor).state;
          
          // Update labels manually if sensors haven't fired yet
          if (temp > 0) {
            char buf[32];
            snprintf(buf, sizeof(buf), "Temp: %.1fC", temp);
            id(temp_label_text) = std::string(buf);
          }
          if (preinf > 0) {
            char buf[32];
            snprintf(buf, sizeof(buf), "PreInf: %.1fs", preinf);
            id(preinfusion_label_text) = std::string(buf);
          }
          {
            std::string state_str = power ? "ON" : "OFF";
            char buf[32];
            snprintf(buf, sizeof(buf), "Power: %s", state_str.c_str());
            id(power_label_text) = std::string(buf);
          }
          if (!steam.empty()) {
            std::string level_num = steam.length() > 5 ? steam.substr(5) : steam;
            char buf[32];
            snprintf(buf, sizeof(buf), "Steam: %s", level_num.c_str());
            id(steam_label_text) = std::string(buf);
          }
          if (!prebrew.empty()) {
            char buf[32];
            snprintf(buf, sizeof(buf), "PreBrew: %s", prebrew.c_str());
            id(prebrew_label_text) = std::string(buf);
          }
      - lvgl.label.update:
          id: temp_label
          text: !lambda 'return id(temp_label_text);'
      - lvgl.label.update:
          id: preinfusion_label
          text: !lambda 'return id(preinfusion_label_text);'
      - lvgl.label.update:
          id: power_label
          text: !lambda 'return id(power_label_text);'
      - lvgl.label.update:
          id: steam_label
          text: !lambda 'return id(steam_label_text);'
      - lvgl.label.update:
          id: prebrew_label
          text: !lambda 'return id(prebrew_label_text);'

  # Update brewing duration
  - id: update_brewing_duration
    then:
      - lambda: |-
          std::string start_time_str = id(lm_status_sensor).state;
          if (start_time_str.empty() || start_time_str == "null" || start_time_str == "unknown" || start_time_str == "None") {
            id(brewing_duration) = 0.0f;
            id(brewing_label_text) = "Brewing: --.-s";
          } else {
            // Increment brewing duration by 0.1s each second
            // Note: This is a simplified approach. For accurate timing, you'd need to parse
            // the ISO 8601 timestamp and calculate the actual difference
            float duration = id(brewing_duration) + 0.1f;
            
            char buf[32];
            snprintf(buf, sizeof(buf), "Brewing: %.1fs", duration);
            id(brewing_label_text) = std::string(buf);
            id(brewing_duration) = duration;
          }
      - lvgl.label.update:
          id: brewing_label
          text: !lambda 'return id(brewing_label_text);'

# Touch screen handlers are in waveshare.yaml, but we add element selection here
# We'll use a lambda in the touchscreen on_touch to call our script

